


Considerando el siguiente ejemplo C++ que demuestra el principio de utilizar la composición y las interfaces para lograr la reutilización del código y el polimorfismo. Debido a que el lenguaje C++ no tiene una palabra clave dedicada para declarar interfaces, vamos a usar la **herencia de una clase base abstracta pura**, que es **funcionalmente equivalente a las interfaces** proporcionadas en otros lenguajes, como Java.

Creamos las siguientes clases:

- Clase abstracta **DelegadoVisibilidad**, con las subclases **Invisible** y **Visible**, que simulan una forma de indicar cuando mostrar o no un objeto (instancia de **Objeto**) en pantalla .
- Clase abstracta **DelegadoActualizacion**, con las subclases **Inamovible** y **Movible**, que ofrecen una forma de mover el objeto en pantalla.
- Clase abstracta **DelegadoColision**, con las subclases **Solido**, **Liquido** y **Gaseoso**, que ofrecen una forma de identificar cómo colisionarán entre sí dos objetos.
- Clase **Objeto** con miembros para controlar su visibilidad (usando un *DelegadoVisibilidad*), movilidad (usando un *DelegadoActualizacion*), y colision (usando un DelegadoColision). Esta clase tiene métodos que delegan en sus miembros, por ejemplo, *actualiza()* simplemente llama a un método del *DelegadoActualizacion*.
- Un par de subclases concretas **Jugador** y **Humo** que heradan de *Objeto*

<br/>

---

```c++
class DelegadoVisibilidad
{
public:
    virtual void dibuja() = 0;
};

class Invisible : public DelegadoVisibilidad
{
public:
    virtual void dibuja() override {
        // no-op
    }
};

class Visible : public DelegadoVisibilidad
{
public:
    virtual void dibuja() override {
        // código para dibujar un modelo en la posición del objeto.
    }
};

class DelegadoActualizacion
{
public:
    virtual void actualiza() = 0;
};

class Inamovible : public DelegadoActualizacion
{
public:
    virtual void actualiza() override {
        // no-op
    }
};

class Movible : public DelegadoActualizacion
{
public:
    virtual void actualiza() override {
        // código para actualizar la posición en pantalla del objeto
    }
};

class DelegadoColision
{
public:
    virtual void colision(Objecto objectos[]) = 0;
};

class Gaseoso : public DelegadoColision
{
public:
    virtual void colision(Objecto objectos[]) override {
        // no-op
    }
};

class Liquido : public DelegadoColision
{
public:
    virtual void colision(Objecto objectos[]) override {
        // código comprueba y reaciona a la colisión con otro objeto
    }
};

class Solido : public DelegadoColision
{
public:
    virtual void colision(Objecto objectos[]) override {
        // código comprueba y reaciona a la colisión con otro objeto
    }
};


class Objecto
{
    DelegadoVisibilidad*   _v;
    DelegadoActualizacion* _u;
    DelegadoColision*      _c;

public:
    Object(DelegadoVisibilidad* v, DelegadoActualizacion* u, DelegadoColision* c)
        : _v(v)
        , _u(u)
        , _c(c)
    {}

    void actualiza() {
        _u->actualiza();
    }

    void dibuja() {
        _v->dibuja();
    }

    void colisiona(Objecto objectos[]) {
        _c->colisiona(objectos);
    }
};

class Jugador : public Objecto
{
public:
    Jugador()
        : Objecto(new Visible(), new Movible(), new Solido())
    {}

    // ...
};

class Coche : public Objecto
{
public:
    Coche()
        : Objecto(new Visible(), new Movible(), new Solido())
    {}

    // ...
};

class Humo : public Objecto
{
public:
    Humo()
        : Object(new Visible(), new Movible(), new Gaseoso())
    {}

    // ...
};

class Charco : public Objecto
{
public:
    Charco()
        : Object(new Visible(), new Inamovible(), new Liquido())
    {}

    // ...
};
```

Escribe el código del ejemplo usando archivos de cabecera (.h) y archivos de implementación (.cpp),
siguiendo una estructura típica en proyectos C++ y añade comentarios explicando el propósito de
cada uno de los elementos y métodos y que sean compatibles con doxygen.

Además, amplia ligeramente las clases y añade un archivo main.cpp para demostrar su uso, donde se
simule la creación de varios objetos que se mueven de forma aleatoria pon una pantalla virtual,
y que vaya mostrando con mensajes de texto cuando colisionan y no pasa nada y cuando la colisión
si que provocaría un accidente
